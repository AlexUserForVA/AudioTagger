
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>madmom.audio.signal &#8212; Audio Tagger 1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/classic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../../_static/language_data.js"></script>
    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Audio Tagger 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for madmom.audio.signal</h1><div class="highlight"><pre>
<span></span><span class="c1"># encoding: utf-8</span>
<span class="c1"># pylint: disable=no-member</span>
<span class="c1"># pylint: disable=invalid-name</span>
<span class="c1"># pylint: disable=too-many-arguments</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains basic signal processing functionality.</span>

<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">..processors</span> <span class="k">import</span> <span class="n">BufferProcessor</span><span class="p">,</span> <span class="n">Processor</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">integer_types</span>


<span class="c1"># signal functions</span>
<span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kernel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Smooth the signal along its first axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be smoothed.</span>
<span class="sd">    kernel : numpy array or int</span>
<span class="sd">        Smoothing kernel (size).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Smoothed signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `kernel` is an integer, a Hamming window of that length will be used</span>
<span class="sd">    as a smoothing kernel.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># check if a kernel is given</span>
    <span class="k">if</span> <span class="n">kernel</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signal</span>
    <span class="c1"># size for the smoothing kernel is given</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">kernel</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">signal</span>
        <span class="k">elif</span> <span class="n">kernel</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># use a Hamming window of given length</span>
            <span class="n">kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">kernel</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t create a smoothing kernel of size </span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                             <span class="n">kernel</span><span class="p">)</span>
    <span class="c1"># otherwise use the given smoothing kernel directly</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kernel</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">kernel</span> <span class="o">=</span> <span class="n">kernel</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;can&#39;t smooth signal with </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">kernel</span><span class="p">)</span>
    <span class="c1"># convolve with the kernel and return</span>
    <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kernel</span><span class="p">,</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="k">import</span> <span class="n">convolve2d</span>
        <span class="k">return</span> <span class="n">convolve2d</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">kernel</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;signal must be either 1D or 2D&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">adjust_gain</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">gain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;&quot;</span>
<span class="sd">    Adjust the gain of the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be adjusted.</span>
<span class="sd">    gain : float</span>
<span class="sd">        Gain adjustment level [dB].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Signal with adjusted gain.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The signal is returned with the same dtype, thus rounding errors may occur</span>
<span class="sd">    with integer dtypes.</span>

<span class="sd">    `gain` values &gt; 0 amplify the signal and are only supported for signals</span>
<span class="sd">    with float dtype to prevent clipping and integer overflows.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert the gain in dB to a scaling factor</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">10.</span><span class="p">),</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">gain</span><span class="p">)</span>
    <span class="c1"># prevent overflow and clipping</span>
    <span class="k">if</span> <span class="n">gain</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;positive gain adjustments are only supported for &#39;</span>
                         <span class="s1">&#39;float dtypes.&#39;</span><span class="p">)</span>
    <span class="c1"># Note: np.asanyarray returns the signal&#39;s ndarray subclass</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">signal</span> <span class="o">*</span> <span class="n">gain</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">attenuate</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">attenuation</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attenuate the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be attenuated.</span>
<span class="sd">    attenuation :  float</span>
<span class="sd">        Attenuation level [dB].</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Attenuated signal (same dtype as `signal`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The signal is returned with the same dtype, thus rounding errors may occur</span>
<span class="sd">    with integer dtypes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># return the signal unaltered if no attenuation is given</span>
    <span class="k">if</span> <span class="n">attenuation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signal</span>
    <span class="k">return</span> <span class="n">adjust_gain</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">-</span><span class="n">attenuation</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalize the signal to have maximum amplitude.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be normalized.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Normalized signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Signals with float dtypes cover the range [-1, +1], signals with integer</span>
<span class="sd">    dtypes will cover the maximally possible range, e.g. [-32768, 32767] for</span>
<span class="sd">    np.int16.</span>

<span class="sd">    The signal is returned with the same dtype, thus rounding errors may occur</span>
<span class="sd">    with integer dtypes.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># scaling factor to be applied</span>
    <span class="n">scaling</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">)))</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int16</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">):</span>
            <span class="n">scaling</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only float and np.int16/32 dtypes supported, &#39;</span>
                             <span class="s1">&#39;not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Note: np.asanyarray returns the signal&#39;s ndarray subclass</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">signal</span> <span class="o">/</span> <span class="n">scaling</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">remix</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Remix the signal to have the desired number of channels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be remixed.</span>
<span class="sd">    num_channels : int</span>
<span class="sd">        Number of channels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Remixed signal (same dtype as `signal`).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function does not support arbitrary channel number conversions.</span>
<span class="sd">    Only down-mixing to and up-mixing from mono signals is supported.</span>

<span class="sd">    The signal is returned with the same dtype, thus rounding errors may occur</span>
<span class="sd">    with integer dtypes.</span>

<span class="sd">    If the signal should be down-mixed to mono and has an integer dtype, it</span>
<span class="sd">    will be converted to float internally and then back to the original dtype</span>
<span class="sd">    to prevent clipping of the signal. To avoid this double conversion,</span>
<span class="sd">    convert the dtype first.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># convert to the desired number of channels</span>
    <span class="k">if</span> <span class="n">num_channels</span> <span class="o">==</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">num_channels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># return as many channels as there are.</span>
        <span class="k">return</span> <span class="n">signal</span>
    <span class="k">elif</span> <span class="n">num_channels</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># down-mix to mono</span>
        <span class="c1"># Note: to prevent clipping, the signal is converted to float first</span>
        <span class="c1">#       and then converted back to the original dtype</span>
        <span class="c1"># TODO: add weighted mixing</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">num_channels</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">signal</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># up-mix a mono signal simply by copying channels</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">signal</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">num_channels</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># any other channel conversion is not supported</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Requested </span><span class="si">%d</span><span class="s2"> channels, but got </span><span class="si">%d</span><span class="s2"> channels &quot;</span>
                                  <span class="s2">&quot;and channel conversion is not implemented.&quot;</span>
                                  <span class="o">%</span> <span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>


<span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resample the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array or Signal</span>
<span class="sd">        Signal to be resampled.</span>
<span class="sd">    sample_rate : int</span>
<span class="sd">        Sample rate of the signal.</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        Keyword arguments passed to :func:`load_ffmpeg_file`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array or Signal</span>
<span class="sd">        Resampled signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function uses ``ffmpeg`` to resample the signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span> <span class="nn">..io.audio</span> <span class="k">import</span> <span class="n">load_ffmpeg_file</span>
    <span class="c1"># is the given signal a Signal?</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">Signal</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only Signals can resampled, not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">==</span> <span class="n">sample_rate</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">signal</span>
    <span class="c1"># per default use the signal&#39;s dtype and num_channels</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="n">num_channels</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;num_channels&#39;</span><span class="p">,</span> <span class="n">signal</span><span class="o">.</span><span class="n">num_channels</span><span class="p">)</span>
    <span class="c1"># resample the signal</span>
    <span class="n">signal</span><span class="p">,</span> <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">load_ffmpeg_file</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
                                           <span class="n">num_channels</span><span class="o">=</span><span class="n">num_channels</span><span class="p">,</span>
                                           <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># return it</span>
    <span class="k">return</span> <span class="n">Signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">rescale</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Rescale the signal to range [-1, 1] and return as float dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be remixed.</span>
<span class="sd">    dtype : numpy dtype</span>
<span class="sd">        Data type of the signal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Signal rescaled to range [-1, 1].</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># allow only float dtypes</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only float dtypes are supported, not </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># float signals don&#39;t need rescaling</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;unsupported signal dtype: </span><span class="si">%s</span><span class="s1">.&#39;</span> <span class="o">%</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">trim</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="s1">&#39;fb&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim leading and trailing zeros of the signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal to be trimmed.</span>
<span class="sd">    where : str, optional</span>
<span class="sd">        A string with &#39;f&#39; representing trim from front and &#39;b&#39; to trim from</span>
<span class="sd">        back. Default is &#39;fb&#39;, trim zeros from both ends of the signal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy array</span>
<span class="sd">        Trimmed signal.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># code borrowed from np.trim_zeros()</span>
    <span class="n">first</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">where</span> <span class="o">=</span> <span class="n">where</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="s1">&#39;F&#39;</span> <span class="ow">in</span> <span class="n">where</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">last</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="k">if</span> <span class="s1">&#39;B&#39;</span> <span class="ow">in</span> <span class="n">where</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">!=</span> <span class="mf">0.</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">last</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">signal</span><span class="p">[</span><span class="n">first</span><span class="p">:</span><span class="n">last</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">energy</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the energy of a (framed) signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    energy : float</span>
<span class="sd">        Energy of the signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `signal` is a `FramedSignal`, the energy is computed for each frame</span>
<span class="sd">    individually.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the energy for every frame of the signal</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">FramedSignal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">energy</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">])</span>
    <span class="c1"># make sure the signal is a numpy array</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Invalid type for signal, must be a numpy array.&quot;</span><span class="p">)</span>
    <span class="c1"># take the abs if the signal is complex</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplex</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="c1"># Note: type conversion needed because of integer overflows</span>
    <span class="k">if</span> <span class="n">signal</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">:</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
    <span class="c1"># return energy</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">signal</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">root_mean_square</span><span class="p">(</span><span class="n">signal</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the root mean square of a (framed) signal. This can be used as a</span>
<span class="sd">    measurement of power.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rms : float</span>
<span class="sd">        Root mean square of the signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `signal` is a `FramedSignal`, the root mean square is computed for each</span>
<span class="sd">    frame individually.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the root mean square for every frame of the signal</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">FramedSignal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">root_mean_square</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">energy</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span> <span class="o">/</span> <span class="n">signal</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">sound_pressure_level</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">p_ref</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the sound pressure level of a (framed) signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal.</span>
<span class="sd">    p_ref : float, optional</span>
<span class="sd">        Reference sound pressure level; if &#39;None&#39;, take the max amplitude</span>
<span class="sd">        value for the data-type, if the data-type is float, assume amplitudes</span>
<span class="sd">        are between -1 and +1.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    spl : float</span>
<span class="sd">        Sound pressure level of the signal [dB].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    From http://en.wikipedia.org/wiki/Sound_pressure: Sound pressure level</span>
<span class="sd">    (SPL) or sound level is a logarithmic measure of the effective sound</span>
<span class="sd">    pressure of a sound relative to a reference value. It is measured in</span>
<span class="sd">    decibels (dB) above a standard reference level.</span>

<span class="sd">    If `signal` is a `FramedSignal`, the sound pressure level is computed for</span>
<span class="sd">    each frame individually.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compute the sound pressure level for every frame of the signal</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">FramedSignal</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sound_pressure_level</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span> <span class="k">for</span> <span class="n">frame</span> <span class="ow">in</span> <span class="n">signal</span><span class="p">])</span>
    <span class="c1"># compute the RMS</span>
    <span class="n">rms</span> <span class="o">=</span> <span class="n">root_mean_square</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="c1"># find a reasonable default reference value if None is given</span>
    <span class="k">if</span> <span class="n">p_ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
            <span class="n">p_ref</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">iinfo</span><span class="p">(</span><span class="n">signal</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">p_ref</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="c1"># normal SPL computation. ignore warnings when taking the log of 0,</span>
    <span class="c1"># then replace the resulting -inf values with the smallest finite number</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="mf">20.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">rms</span> <span class="o">/</span> <span class="n">p_ref</span><span class="p">))</span>


<span class="c1"># functions to load / write audio files</span>
<span class="k">class</span> <span class="nc">LoadAudioFileError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated as of version 0.16. Please use</span>
<span class="sd">    madmom.io.audio.LoadAudioFileError instead. Will be removed in version</span>
<span class="sd">    0.18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=super-init-not-called</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">LoadAudioFileError</span><span class="o">.</span><span class="vm">__doc__</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;Could not load audio file.&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">def</span> <span class="nf">load_wave_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated as of version 0.16. Please use madmom.io.audio.load_wave_file</span>
<span class="sd">    instead. Will be removed in version 0.18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecated as of version 0.16. Please use madmom.io.audio.&#39;</span>
                  <span class="s1">&#39;load_wave_file instead. Will be removed in version 0.18.&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">..io.audio</span> <span class="k">import</span> <span class="n">load_wave_file</span>
    <span class="k">return</span> <span class="n">load_wave_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">write_wave_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated as of version 0.16. Please use madmom.io.audio.write_wave_file</span>
<span class="sd">    instead. Will be removed in version 0.18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecated as of version 0.16. Please use madmom.io.audio.&#39;</span>
                  <span class="s1">&#39;write_wave_file instead. Will be removed in version 0.18.&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">..io.audio</span> <span class="k">import</span> <span class="n">write_wave_file</span>
    <span class="k">return</span> <span class="n">write_wave_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># function for automatically determining how to open audio files</span>
<span class="k">def</span> <span class="nf">load_audio_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deprecated as of version 0.16. Please use madmom.io.audio.load_audio_file</span>
<span class="sd">    instead. Will be removed in version 0.18.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Deprecated as of version 0.16. Please use madmom.io.audio.&#39;</span>
                  <span class="s1">&#39;load_audio_file instead. Will be removed in version 0.18.&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">..io.audio</span> <span class="k">import</span> <span class="n">load_audio_file</span>
    <span class="k">return</span> <span class="n">load_audio_file</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># signal classes</span>
<span class="n">SAMPLE_RATE</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">NUM_CHANNELS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">START</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">STOP</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">NORM</span> <span class="o">=</span> <span class="kc">False</span>
<span class="n">GAIN</span> <span class="o">=</span> <span class="mf">0.</span>
<span class="n">DTYPE</span> <span class="o">=</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">Signal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`Signal` class represents a signal as a (memory-mapped) numpy</span>
<span class="sd">    array and enhances it with a number of attributes.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : numpy array, str or file handle</span>
<span class="sd">        Signal data or file name or file handle.</span>
<span class="sd">    sample_rate : int, optional</span>
<span class="sd">        Desired sample rate of the signal [Hz], or &#39;None&#39; to return the</span>
<span class="sd">        signal in its original rate.</span>
<span class="sd">    num_channels : int, optional</span>
<span class="sd">        Reduce or expand the signal to `num_channels` channels, or &#39;None&#39;</span>
<span class="sd">        to return the signal with its original channels.</span>
<span class="sd">    start : float, optional</span>
<span class="sd">        Start position [seconds].</span>
<span class="sd">    stop : float, optional</span>
<span class="sd">        Stop position [seconds].</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        Normalize the signal to maximum range of the data type.</span>
<span class="sd">    gain : float, optional</span>
<span class="sd">        Adjust the gain of the signal [dB].</span>
<span class="sd">    dtype : numpy data type, optional</span>
<span class="sd">        The data is returned with the given dtype. If &#39;None&#39;, it is returned</span>
<span class="sd">        with its original dtype, otherwise the signal gets rescaled. Integer</span>
<span class="sd">        dtypes use the complete value range, float dtypes the range [-1, +1].</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `sample_rate` or `num_channels` can be used to set the desired sample rate</span>
<span class="sd">    and number of channels if the audio is read from file. If set to &#39;None&#39;</span>
<span class="sd">    the audio signal is used as is, i.e. the sample rate and number of channels</span>
<span class="sd">    are determined directly from the audio file.</span>

<span class="sd">    If the `data` is a numpy array, the `sample_rate` is set to the given value</span>
<span class="sd">    and `num_channels` is set to the number of columns of the array.</span>

<span class="sd">    The `gain` can be used to adjust the level of the signal.</span>

<span class="sd">    If both `norm` and `gain` are set, the signal is first normalized and then</span>
<span class="sd">    the gain is applied afterwards.</span>

<span class="sd">    If `norm` or `gain` is set, the selected part of the signal is loaded into</span>
<span class="sd">    memory completely, i.e. .wav files are not memory-mapped any more.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Load a mono audio file:</span>

<span class="sd">    &gt;&gt;&gt; sig = Signal(&#39;tests/data/audio/sample.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([-2494, -2510, ...,   655,   639], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; sig.sample_rate</span>
<span class="sd">    44100</span>

<span class="sd">    Load a stereo audio file, down-mix it to mono:</span>

<span class="sd">    &gt;&gt;&gt; sig = Signal(&#39;tests/data/audio/stereo_sample.flac&#39;, num_channels=1)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([ 36,  36, ..., 524, 495], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; sig.num_channels</span>
<span class="sd">    1</span>

<span class="sd">    Load and re-sample an audio file:</span>

<span class="sd">    &gt;&gt;&gt; sig = Signal(&#39;tests/data/audio/sample.wav&#39;, sample_rate=22050)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([-2470, -2553, ...,   517,   677], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; sig.sample_rate</span>
<span class="sd">    22050</span>

<span class="sd">    Load an audio file with `float32` data type (i.e. rescale it to [-1, 1]):</span>

<span class="sd">    &gt;&gt;&gt; sig = Signal(&#39;tests/data/audio/sample.wav&#39;, dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([-0.07611, -0.0766 , ...,  0.01999,  0.0195 ], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; sig.dtype</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># pylint: disable=super-on-old-class</span>
    <span class="c1"># pylint: disable=super-init-not-called</span>
    <span class="c1"># pylint: disable=attribute-defined-outside-init</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">SAMPLE_RATE</span><span class="p">,</span>
                 <span class="n">num_channels</span><span class="o">=</span><span class="n">NUM_CHANNELS</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="n">START</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">STOP</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">NORM</span><span class="p">,</span>
                 <span class="n">gain</span><span class="o">=</span><span class="n">GAIN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># this method is for documentation purposes only</span>
        <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">SAMPLE_RATE</span><span class="p">,</span> <span class="n">num_channels</span><span class="o">=</span><span class="n">NUM_CHANNELS</span><span class="p">,</span>
                <span class="n">start</span><span class="o">=</span><span class="n">START</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">STOP</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">NORM</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">GAIN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">..io.audio</span> <span class="k">import</span> <span class="n">load_audio_file</span>
        <span class="c1"># try to load an audio file if the data is not a numpy array</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span> <span class="o">=</span> <span class="n">load_audio_file</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
                                                <span class="n">num_channels</span><span class="o">=</span><span class="n">num_channels</span><span class="p">,</span>
                                                <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">stop</span><span class="p">,</span>
                                                <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># cast as Signal if needed</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">Signal</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
        <span class="c1"># remix to desired number of channels</span>
        <span class="k">if</span> <span class="n">num_channels</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">remix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">)</span>
        <span class="c1"># normalize signal if needed</span>
        <span class="k">if</span> <span class="n">norm</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># adjust the gain if needed</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gain</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">adjust_gain</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">gain</span><span class="p">)</span>
        <span class="c1"># resample if needed</span>
        <span class="k">if</span> <span class="n">sample_rate</span> <span class="o">!=</span> <span class="n">data</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">resample</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">)</span>
        <span class="c1"># save start and stop position</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># FIXME: start and stop settings are not checked</span>
            <span class="n">data</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
            <span class="n">data</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">))</span> <span class="o">/</span> <span class="n">sample_rate</span>
        <span class="c1"># return the object</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># set default values here, also needed for views of the Signal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;sample_rate&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;stop&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of samples.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_channels</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Number of channels.&quot;&quot;&quot;</span>
        <span class="c1"># mono file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="c1"># multi channel file</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Length of signal in seconds.&quot;&quot;&quot;</span>
        <span class="c1"># n/a if the signal has no sample rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the signal to disk as a .wav file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of the file.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Name of the written file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">write_wave_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Energy of signal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">root_mean_square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Root mean square of signal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_mean_square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">rms</span> <span class="o">=</span> <span class="n">root_mean_square</span>

    <span class="k">def</span> <span class="nf">sound_pressure_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sound pressure level of signal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sound_pressure_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">spl</span> <span class="o">=</span> <span class="n">sound_pressure_level</span>


<span class="k">class</span> <span class="nc">SignalProcessor</span><span class="p">(</span><span class="n">Processor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`SignalProcessor` class is a basic signal processor.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample_rate : int, optional</span>
<span class="sd">        Sample rate of the signal [Hz]; if set the signal will be re-sampled</span>
<span class="sd">        to that sample rate; if &#39;None&#39; the sample rate of the audio file will</span>
<span class="sd">        be used.</span>
<span class="sd">    num_channels : int, optional</span>
<span class="sd">        Number of channels of the signal; if set, the signal will be reduced</span>
<span class="sd">        to that number of channels; if &#39;None&#39; as many channels as present in</span>
<span class="sd">        the audio file are returned.</span>
<span class="sd">    start : float, optional</span>
<span class="sd">        Start position [seconds].</span>
<span class="sd">    stop : float, optional</span>
<span class="sd">        Stop position [seconds].</span>
<span class="sd">    norm : bool, optional</span>
<span class="sd">        Normalize the signal to the range [-1, +1].</span>
<span class="sd">    gain : float, optional</span>
<span class="sd">        Adjust the gain of the signal [dB].</span>
<span class="sd">    dtype : numpy data type, optional</span>
<span class="sd">        The data is returned with the given dtype. If &#39;None&#39;, it is returned</span>
<span class="sd">        with its original dtype, otherwise the signal gets rescaled. Integer</span>
<span class="sd">        dtypes use the complete value range, float dtypes the range [-1, +1].</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Processor for loading the first two seconds of an audio file, re-sampling</span>
<span class="sd">    it to 22.05 kHz and down-mixing it to mono:</span>

<span class="sd">    &gt;&gt;&gt; proc = SignalProcessor(sample_rate=22050, num_channels=1, stop=2)</span>
<span class="sd">    &gt;&gt;&gt; sig = proc(&#39;tests/data/audio/sample.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([-2470, -2553, ...,  -173,  -265], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; sig.sample_rate</span>
<span class="sd">    22050</span>
<span class="sd">    &gt;&gt;&gt; sig.num_channels</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; sig.length</span>
<span class="sd">    2.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">SAMPLE_RATE</span><span class="p">,</span> <span class="n">num_channels</span><span class="o">=</span><span class="n">NUM_CHANNELS</span><span class="p">,</span>
                 <span class="n">start</span><span class="o">=</span><span class="n">START</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="n">STOP</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">NORM</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="n">GAIN</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">DTYPE</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">=</span> <span class="n">num_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stop</span> <span class="o">=</span> <span class="n">stop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gain</span> <span class="o">=</span> <span class="n">gain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Processes the given audio file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : numpy array, str or file handle</span>
<span class="sd">            Data to be processed.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Keyword arguments passed to :class:`Signal`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        signal : :class:`Signal` instance</span>
<span class="sd">            :class:`Signal` instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="c1"># update arguments passed to FramedSignal</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                    <span class="n">num_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
                    <span class="n">stop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">stop</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gain</span><span class="p">,</span>
                    <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># instantiate a Signal and return it</span>
        <span class="k">return</span> <span class="n">Signal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mono</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">gain</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add signal processing related arguments to an existing parser.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parser : argparse parser instance</span>
<span class="sd">            Existing argparse parser object.</span>
<span class="sd">        sample_rate : int, optional</span>
<span class="sd">            Re-sample the signal to this sample rate [Hz].</span>
<span class="sd">        mono : bool, optional</span>
<span class="sd">            Down-mix the signal to mono.</span>
<span class="sd">        start : float, optional</span>
<span class="sd">            Start position [seconds].</span>
<span class="sd">        stop : float, optional</span>
<span class="sd">            Stop position [seconds].</span>
<span class="sd">        norm : bool, optional</span>
<span class="sd">            Normalize the signal to the range [-1, +1].</span>
<span class="sd">        gain : float, optional</span>
<span class="sd">            Adjust the gain of the signal [dB].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        argparse argument group</span>
<span class="sd">            Signal processing argument parser group.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Parameters are included in the group only if they are not &#39;None&#39;. To</span>
<span class="sd">        include `start` and `stop` arguments with a default value of &#39;None&#39;,</span>
<span class="sd">        i.e. do not set any start or stop time, they can be set to &#39;True&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add signal processing options to the existing parser</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">&#39;signal processing arguments&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sample_rate</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--sample_rate&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                           <span class="n">default</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;re-sample the signal to &#39;</span>
                                                     <span class="s1">&#39;this sample rate [Hz]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mono</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--mono&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;num_channels&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_const&#39;</span><span class="p">,</span>
                           <span class="n">const</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s1">&#39;down-mix the signal to mono&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--start&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;start position of the signal [seconds]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--stop&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;stop position of the signal [seconds]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--norm&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_true&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;normalize the signal [default=</span><span class="si">%(default)s</span><span class="s1">]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--gain&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">gain</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;adjust the gain of the signal &#39;</span>
                                <span class="s1">&#39;[dB, default=</span><span class="si">%(default).1f</span><span class="s1">]&#39;</span><span class="p">)</span>
        <span class="c1"># return the argument group so it can be modified if needed</span>
        <span class="k">return</span> <span class="n">g</span>


<span class="c1"># functions for splitting a signal into frames</span>
<span class="k">def</span> <span class="nf">signal_frame</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function returns frame at `index` of the `signal`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : numpy array</span>
<span class="sd">        Signal.</span>
<span class="sd">    index : int</span>
<span class="sd">        Index of the frame to return.</span>
<span class="sd">    frame_size : int</span>
<span class="sd">        Size of each frame in samples.</span>
<span class="sd">    hop_size : float</span>
<span class="sd">        Hop size in samples between adjacent frames.</span>
<span class="sd">    origin : int</span>
<span class="sd">        Location of the window center relative to the signal position.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    frame : numpy array</span>
<span class="sd">        Requested frame of the signal.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The reference sample of the first frame (index == 0) refers to the first</span>
<span class="sd">    sample of the `signal`, and each following frame is placed `hop_size`</span>
<span class="sd">    samples after the previous one.</span>

<span class="sd">    The window is always centered around this reference sample. Its location</span>
<span class="sd">    relative to the reference sample can be set with the `origin` parameter.</span>
<span class="sd">    Arbitrary integer values can be given:</span>

<span class="sd">    - zero centers the window on its reference sample</span>
<span class="sd">    - negative values shift the window to the right</span>
<span class="sd">    - positive values shift the window to the left</span>

<span class="sd">    An `origin` of half the size of the `frame_size` results in windows located</span>
<span class="sd">    to the left of the reference sample, i.e. the first frame starts at the</span>
<span class="sd">    first sample of the signal.</span>

<span class="sd">    The part of the frame which is not covered by the signal is padded with</span>
<span class="sd">    zeros.</span>

<span class="sd">    This function is totally independent of the length of the signal. Thus,</span>
<span class="sd">    contrary to common indexing, the index &#39;-1&#39; refers NOT to the last frame</span>
<span class="sd">    of the signal, but instead the frame left of the first frame is returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># cast variables to int</span>
    <span class="n">frame_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_size</span><span class="p">)</span>
    <span class="c1"># length of the signal</span>
    <span class="n">num_samples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
    <span class="c1"># seek to the correct position in the audio signal</span>
    <span class="n">ref_sample</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">index</span> <span class="o">*</span> <span class="n">hop_size</span><span class="p">)</span>
    <span class="c1"># position the window</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">ref_sample</span> <span class="o">-</span> <span class="n">frame_size</span> <span class="o">//</span> <span class="mi">2</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
    <span class="n">stop</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">frame_size</span>
    <span class="c1"># return the requested portion of the signal</span>
    <span class="c1"># Note: np.pad(signal[from: to], (pad_left, pad_right), mode=&#39;constant&#39;)</span>
    <span class="c1">#       always returns a ndarray, not the subclass (and is slower);</span>
    <span class="c1">#       usually np.zeros_like(signal[:frame_size]) is exactly what we want</span>
    <span class="c1">#       (i.e. zeros of frame_size length and the same type/class as the</span>
    <span class="c1">#       signal and not just the dtype), but since we have no guarantee that</span>
    <span class="c1">#       the signal is that long, we have to use the np.repeat workaround</span>
    <span class="c1"># Note: use NumPy&#39;s advanced indexing (i.e. trailing comma) in order to</span>
    <span class="c1">#       avoid a memory leak (issue #321). This returns a copy of the data,</span>
    <span class="c1">#       however, returning a simple copy of the relevant portion of the</span>
    <span class="c1">#       signal also leaks memory</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">stop</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">):</span>
        <span class="c1"># window falls completely outside the actual signal, return just zeros</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">stop</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">):</span>
        <span class="c1"># window surrounds the actual signal, position signal accordingly</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">frame</span><span class="p">[</span><span class="o">-</span><span class="n">start</span><span class="p">:</span><span class="n">num_samples</span> <span class="o">-</span> <span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="k">elif</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># window crosses left edge of actual signal, pad zeros from left</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">frame</span><span class="p">[</span><span class="o">-</span><span class="n">start</span><span class="p">:]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[:</span><span class="n">stop</span><span class="p">,</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="k">elif</span> <span class="n">stop</span> <span class="o">&gt;</span> <span class="n">num_samples</span><span class="p">:</span>
        <span class="c1"># window crosses right edge of actual signal, pad zeros from right</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">signal</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span><span class="p">,</span> <span class="n">frame_size</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">frame</span><span class="p">[:</span><span class="n">num_samples</span> <span class="o">-</span> <span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">start</span><span class="p">:,</span> <span class="p">]</span>
        <span class="k">return</span> <span class="n">frame</span>
    <span class="c1"># normal read operation</span>
    <span class="k">return</span> <span class="n">signal</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">stop</span><span class="p">,</span> <span class="p">]</span>


<span class="n">FRAME_SIZE</span> <span class="o">=</span> <span class="mi">2048</span>
<span class="n">HOP_SIZE</span> <span class="o">=</span> <span class="mf">441.</span>
<span class="n">FPS</span> <span class="o">=</span> <span class="kc">None</span>
<span class="n">ORIGIN</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">END_OF_SIGNAL</span> <span class="o">=</span> <span class="s1">&#39;normal&#39;</span>
<span class="n">NUM_FRAMES</span> <span class="o">=</span> <span class="kc">None</span>


<span class="c1"># classes for splitting a signal into frames</span>
<span class="k">class</span> <span class="nc">FramedSignal</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The :class:`FramedSignal` splits a :class:`Signal` into frames and makes it</span>
<span class="sd">    iterable and indexable.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    signal : :class:`Signal` instance</span>
<span class="sd">        Signal to be split into frames.</span>
<span class="sd">    frame_size : int, optional</span>
<span class="sd">        Size of one frame [samples].</span>
<span class="sd">    hop_size : float, optional</span>
<span class="sd">        Progress `hop_size` samples between adjacent frames.</span>
<span class="sd">    fps : float, optional</span>
<span class="sd">        Use given frames per second; if set, this computes and overwrites the</span>
<span class="sd">        given `hop_size` value.</span>
<span class="sd">    origin : int, optional</span>
<span class="sd">        Location of the window relative to the reference sample of a frame.</span>
<span class="sd">    end : int or str, optional</span>
<span class="sd">        End of signal handling (see notes below).</span>
<span class="sd">    num_frames : int, optional</span>
<span class="sd">        Number of frames to return.</span>
<span class="sd">    kwargs : dict, optional</span>
<span class="sd">        If no :class:`Signal` instance was given, one is instantiated with</span>
<span class="sd">        these additional keyword arguments.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The :class:`FramedSignal` class is implemented as an iterator. It splits</span>
<span class="sd">    the given `signal` automatically into frames of `frame_size` length with</span>
<span class="sd">    `hop_size` samples (can be float, normal rounding applies) between the</span>
<span class="sd">    frames. The reference sample of the first frame refers to the first sample</span>
<span class="sd">    of the `signal`.</span>

<span class="sd">    The location of the window relative to the reference sample of a frame can</span>
<span class="sd">    be set with the `origin` parameter (with the same behaviour as used by</span>
<span class="sd">    ``scipy.ndimage`` filters). Arbitrary integer values can be given:</span>

<span class="sd">    - zero centers the window on its reference sample,</span>
<span class="sd">    - negative values shift the window to the right,</span>
<span class="sd">    - positive values shift the window to the left.</span>

<span class="sd">    Additionally, it can have the following literal values:</span>

<span class="sd">    - &#39;center&#39;, &#39;offline&#39;: the window is centered on its reference sample,</span>
<span class="sd">    - &#39;left&#39;, &#39;past&#39;, &#39;online&#39;: the window is located to the left of its</span>
<span class="sd">      reference sample (including the reference sample),</span>
<span class="sd">    - &#39;right&#39;, &#39;future&#39;, &#39;stream&#39;: the window is located to the right of its</span>
<span class="sd">      reference sample.</span>

<span class="sd">    The `end` parameter is used to handle the end of signal behaviour and</span>
<span class="sd">    can have these values:</span>

<span class="sd">    - &#39;normal&#39;: stop as soon as the whole signal got covered by at least one</span>
<span class="sd">      frame (i.e. pad maximally one frame),</span>
<span class="sd">    - &#39;extend&#39;: frames are returned as long as part of the frame overlaps</span>
<span class="sd">      with the signal to cover the whole signal.</span>

<span class="sd">    Alternatively, `num_frames` can be used to retrieve a fixed number of</span>
<span class="sd">    frames.</span>

<span class="sd">    In order to be able to stack multiple frames obtained with different frame</span>
<span class="sd">    sizes, the number of frames to be returned must be independent from the set</span>
<span class="sd">    `frame_size`. It is not guaranteed that every sample of the signal is</span>
<span class="sd">    returned in a frame unless the `origin` is either &#39;right&#39; or &#39;future&#39;.</span>

<span class="sd">    If used in online real-time mode the parameters `origin` and `num_frames`</span>
<span class="sd">    should be set to &#39;stream&#39; and 1, respectively.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    To chop a :class:`Signal` (or anything a :class:`Signal` can be</span>
<span class="sd">    instantiated from) into overlapping frames of size 2048 with adjacent</span>
<span class="sd">    frames being 441 samples apart:</span>

<span class="sd">    &gt;&gt;&gt; sig = Signal(&#39;tests/data/audio/sample.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; sig</span>
<span class="sd">    Signal([-2494, -2510, ...,   655,   639], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames = FramedSignal(sig, frame_size=2048, hop_size=441)</span>
<span class="sd">    &gt;&gt;&gt; frames  # doctest: +ELLIPSIS</span>
<span class="sd">    &lt;madmom.audio.signal.FramedSignal object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; frames[0]</span>
<span class="sd">    Signal([    0,     0, ..., -4666, -4589], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames[10]</span>
<span class="sd">    Signal([-6156, -5645, ...,  -253,   671], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames.fps</span>
<span class="sd">    100.0</span>

<span class="sd">    Instead of passing a :class:`Signal` instance as the first argument,</span>
<span class="sd">    anything a :class:`Signal` can be instantiated from (e.g. a file name) can</span>
<span class="sd">    be used. We can also set the frames per second (`fps`) instead, they get</span>
<span class="sd">    converted to `hop_size` based on the `sample_rate` of the signal:</span>

<span class="sd">    &gt;&gt;&gt; frames = FramedSignal(&#39;tests/data/audio/sample.wav&#39;, fps=100)</span>
<span class="sd">    &gt;&gt;&gt; frames  # doctest: +ELLIPSIS</span>
<span class="sd">    &lt;madmom.audio.signal.FramedSignal object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; frames[0]</span>
<span class="sd">    Signal([    0,     0, ..., -4666, -4589], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames.frame_size, frames.hop_size</span>
<span class="sd">    (2048, 441.0)</span>

<span class="sd">    When trying to access an out of range frame, an IndexError is raised. Thus</span>
<span class="sd">    the FramedSignal can be used the same way as a numpy array or any other</span>
<span class="sd">    iterable.</span>

<span class="sd">    &gt;&gt;&gt; frames = FramedSignal(&#39;tests/data/audio/sample.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; frames.num_frames</span>
<span class="sd">    281</span>
<span class="sd">    &gt;&gt;&gt; frames[281]</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">    IndexError: end of signal reached</span>
<span class="sd">    &gt;&gt;&gt; frames.shape</span>
<span class="sd">    (281, 2048)</span>

<span class="sd">    Slices are FramedSignals itself:</span>

<span class="sd">    &gt;&gt;&gt; frames[:4]  # doctest: +ELLIPSIS</span>
<span class="sd">    &lt;madmom.audio.signal.FramedSignal object at 0x...&gt;</span>

<span class="sd">    To obtain a numpy array from a FramedSignal, simply use np.array() on the</span>
<span class="sd">    full FramedSignal or a slice of it. Please note, that this requires a full</span>
<span class="sd">    memory copy.</span>

<span class="sd">    &gt;&gt;&gt; np.array(frames[2:4])</span>
<span class="sd">    array([[    0,     0, ..., -5316, -5405],</span>
<span class="sd">           [ 2215,  2281, ...,   561,   653]], dtype=int16)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">signal</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="n">FRAME_SIZE</span><span class="p">,</span> <span class="n">hop_size</span><span class="o">=</span><span class="n">HOP_SIZE</span><span class="p">,</span>
                 <span class="n">fps</span><span class="o">=</span><span class="n">FPS</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">ORIGIN</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">END_OF_SIGNAL</span><span class="p">,</span>
                 <span class="n">num_frames</span><span class="o">=</span><span class="n">NUM_FRAMES</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>

        <span class="c1"># signal handling</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">Signal</span><span class="p">):</span>
            <span class="c1"># try to instantiate a Signal</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># save the signal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span>

        <span class="c1"># arguments for splitting the signal into frames</span>
        <span class="k">if</span> <span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">hop_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">hop_size</span><span class="p">)</span>
        <span class="c1"># use fps instead of hop_size</span>
        <span class="k">if</span> <span class="n">fps</span><span class="p">:</span>
            <span class="c1"># overwrite the hop_size</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>

        <span class="c1"># translate literal window location values to numeric origin</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="s1">&#39;offline&#39;</span><span class="p">):</span>
            <span class="c1"># window centered around the origin</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;past&#39;</span><span class="p">,</span> <span class="s1">&#39;online&#39;</span><span class="p">):</span>
            <span class="c1"># origin is the right edge of the frame, i.e. window to the left</span>
            <span class="c1"># Note: used when simulating online mode, where only past</span>
            <span class="c1">#       information of the audio signal can be used</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">frame_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="s1">&#39;future&#39;</span><span class="p">,</span> <span class="s1">&#39;stream&#39;</span><span class="p">):</span>
            <span class="c1"># origin is the left edge of the frame, i.e. window to the right</span>
            <span class="c1"># Note: used when operating on live audio streams where we want</span>
            <span class="c1">#       to retrieve a single frame. Instead of using &#39;online&#39;, we</span>
            <span class="c1">#       &quot;fake&quot; the origin in order to retrieve the complete frame</span>
            <span class="c1">#       provided by FramedSignalProcessor. This is a workaround to</span>
            <span class="c1">#       be able to use the same processing chain in different modes</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">frame_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># number of frames determination</span>
        <span class="k">if</span> <span class="n">num_frames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="s1">&#39;extend&#39;</span><span class="p">:</span>
                <span class="c1"># return frames as long as a frame covers any signal</span>
                <span class="n">num_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span> <span class="o">/</span>
                                      <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">end</span> <span class="o">==</span> <span class="s1">&#39;normal&#39;</span><span class="p">:</span>
                <span class="c1"># return frames as long as the origin sample covers the signal</span>
                <span class="n">num_frames</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;end of signal handling &#39;</span><span class="si">%s</span><span class="s2">&#39; unknown&quot;</span> <span class="o">%</span>
                                 <span class="n">end</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)</span>

    <span class="c1"># make the object indexable / iterable</span>
    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This makes the :class:`FramedSignal` class indexable and/or iterable.</span>

<span class="sd">        The signal is split into frames (of length `frame_size`) automatically.</span>
<span class="sd">        Two frames are located `hop_size` samples apart. If `hop_size` is a</span>
<span class="sd">        float, normal rounding applies.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a single index is given</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="c1"># negative indices</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span>
            <span class="c1"># return the frame at the given index</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">signal_frame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                    <span class="n">frame_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">,</span>
                                    <span class="n">hop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
            <span class="c1"># otherwise raise an error to indicate the end of signal</span>
            <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;end of signal reached&quot;</span><span class="p">)</span>
        <span class="c1"># a slice is given</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="c1"># determine the frames to return (limited to the number of frames)</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span><span class="p">)</span>
            <span class="c1"># allow only normal steps</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;only slices with a step size of 1 supported&#39;</span><span class="p">)</span>
            <span class="c1"># determine the number of frames</span>
            <span class="n">num_frames</span> <span class="o">=</span> <span class="n">stop</span> <span class="o">-</span> <span class="n">start</span>
            <span class="c1"># determine the new origin, i.e. start position</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">*</span> <span class="n">start</span>
            <span class="c1"># return a new FramedSignal instance covering the requested frames</span>
            <span class="k">return</span> <span class="n">FramedSignal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">,</span>
                                <span class="n">hop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
                                <span class="n">num_frames</span><span class="o">=</span><span class="n">num_frames</span><span class="p">)</span>
        <span class="c1"># other index types are invalid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;frame indices must be slices or integers&quot;</span><span class="p">)</span>

    <span class="c1"># len() returns the number of frames, consistent with __getitem__()</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">frame_rate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frame rate (same as fps).&quot;&quot;&quot;</span>
        <span class="c1"># n/a if the signal has no sample rate</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sample_rate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fps</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Frames per second.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_rate</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">overlap_factor</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Overlapping factor of two adjacent frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shape of the FramedSignal (num_frames, frame_size[, num_channels]).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">num_channels</span><span class="p">,</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Dimensionality of the FramedSignal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Energy of the individual frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">root_mean_square</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Root mean square of the individual frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">root_mean_square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">rms</span> <span class="o">=</span> <span class="n">root_mean_square</span>

    <span class="k">def</span> <span class="nf">sound_pressure_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sound pressure level of the individual frames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">sound_pressure_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="n">spl</span> <span class="o">=</span> <span class="n">sound_pressure_level</span>


<span class="k">class</span> <span class="nc">FramedSignalProcessor</span><span class="p">(</span><span class="n">Processor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Slice a Signal into frames.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame_size : int, optional</span>
<span class="sd">        Size of one frame [samples].</span>
<span class="sd">    hop_size : float, optional</span>
<span class="sd">        Progress `hop_size` samples between adjacent frames.</span>
<span class="sd">    fps : float, optional</span>
<span class="sd">        Use given frames per second; if set, this computes and overwrites the</span>
<span class="sd">        given `hop_size` value.</span>
<span class="sd">    origin : int, optional</span>
<span class="sd">        Location of the window relative to the reference sample of a frame.</span>
<span class="sd">    end : int or str, optional</span>
<span class="sd">        End of signal handling (see :class:`FramedSignal`).</span>
<span class="sd">    num_frames : int, optional</span>
<span class="sd">        Number of frames to return.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    When operating on live audio signals, `origin` must be set to &#39;stream&#39; in</span>
<span class="sd">    order to retrieve always the last `frame_size` samples.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Processor for chopping a :class:`Signal` (or anything a :class:`Signal` can</span>
<span class="sd">    be instantiated from) into overlapping frames of size 2048, and a frame</span>
<span class="sd">    rate of 100 frames per second:</span>

<span class="sd">    &gt;&gt;&gt; proc = FramedSignalProcessor(frame_size=2048, fps=100)</span>
<span class="sd">    &gt;&gt;&gt; frames = proc(&#39;tests/data/audio/sample.wav&#39;)</span>
<span class="sd">    &gt;&gt;&gt; frames  # doctest: +ELLIPSIS</span>
<span class="sd">    &lt;madmom.audio.signal.FramedSignal object at 0x...&gt;</span>
<span class="sd">    &gt;&gt;&gt; frames[0]</span>
<span class="sd">    Signal([    0,     0, ..., -4666, -4589], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames[10]</span>
<span class="sd">    Signal([-6156, -5645, ...,  -253,   671], dtype=int16)</span>
<span class="sd">    &gt;&gt;&gt; frames.hop_size</span>
<span class="sd">    441.0</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="n">FRAME_SIZE</span><span class="p">,</span> <span class="n">hop_size</span><span class="o">=</span><span class="n">HOP_SIZE</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">FPS</span><span class="p">,</span>
                 <span class="n">origin</span><span class="o">=</span><span class="n">ORIGIN</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">END_OF_SIGNAL</span><span class="p">,</span> <span class="n">num_frames</span><span class="o">=</span><span class="n">NUM_FRAMES</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># pylint: disable=unused-argument</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="n">frame_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">=</span> <span class="n">hop_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fps</span> <span class="o">=</span> <span class="n">fps</span>  <span class="c1"># do not convert here, pass it to FramedSignal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span> <span class="o">=</span> <span class="n">num_frames</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Slice the signal into (overlapping) frames.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : :class:`Signal` instance</span>
<span class="sd">            Signal to be sliced into frames.</span>
<span class="sd">        kwargs : dict, optional</span>
<span class="sd">            Keyword arguments passed to :class:`FramedSignal`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frames : :class:`FramedSignal` instance</span>
<span class="sd">            FramedSignal instance</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># update arguments passed to FramedSignal</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">frame_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">,</span> <span class="n">hop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span>
                    <span class="n">fps</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">fps</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
                    <span class="n">num_frames</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_frames</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># always use the last `frame_size` samples if we operate on a live</span>
        <span class="c1"># audio stream, otherwise we get the wrong portion of the signal</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">origin</span> <span class="o">==</span> <span class="s1">&#39;stream&#39;</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:]</span>
        <span class="c1"># instantiate a FramedSignal from the data and return it</span>
        <span class="k">return</span> <span class="n">FramedSignal</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">**</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">add_arguments</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="n">FRAME_SIZE</span><span class="p">,</span> <span class="n">fps</span><span class="o">=</span><span class="n">FPS</span><span class="p">,</span>
                      <span class="n">online</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add signal framing related arguments to an existing parser.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parser : argparse parser instance</span>
<span class="sd">            Existing argparse parser object.</span>
<span class="sd">        frame_size : int, optional</span>
<span class="sd">            Size of one frame in samples.</span>
<span class="sd">        fps : float, optional</span>
<span class="sd">            Frames per second.</span>
<span class="sd">        online : bool, optional</span>
<span class="sd">            Online mode (use only past signal information, i.e. align the</span>
<span class="sd">            window to the left of the reference sample).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        argparse argument group</span>
<span class="sd">            Signal framing argument parser group.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Parameters are included in the group only if they are not &#39;None&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add signal framing options to the existing parser</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">add_argument_group</span><span class="p">(</span><span class="s1">&#39;signal framing arguments&#39;</span><span class="p">)</span>
        <span class="c1"># depending on the type of frame_size, use different options</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_size</span><span class="p">,</span> <span class="n">integer_types</span><span class="p">):</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--frame_size&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span>
                           <span class="n">default</span><span class="o">=</span><span class="n">frame_size</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;frame size [samples, default=</span><span class="si">%(default)i</span><span class="s1">]&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">frame_size</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Note: this option can be used to stack multiple spectrograms</span>
            <span class="c1">#       with different frame sizes</span>
            <span class="kn">from</span> <span class="nn">..utils</span> <span class="k">import</span> <span class="n">OverrideDefaultListAction</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--frame_size&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">frame_size</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">OverrideDefaultListAction</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;(comma separated list of) frame size(s) to &#39;</span>
                                <span class="s1">&#39;use [samples, default=</span><span class="si">%(default)s</span><span class="s1">]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--fps&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">fps</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;frames per second [default=</span><span class="si">%(default).1f</span><span class="s1">]&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">online</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--online&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_const&#39;</span><span class="p">,</span>
                           <span class="n">const</span><span class="o">=</span><span class="s1">&#39;online&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;offline&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;operate in online mode [default=offline]&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">online</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--offline&#39;</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="s1">&#39;origin&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;store_const&#39;</span><span class="p">,</span>
                           <span class="n">const</span><span class="o">=</span><span class="s1">&#39;offline&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;online&#39;</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;operate in offline mode [default=online]&#39;</span><span class="p">)</span>
        <span class="c1"># return the argument group so it can be modified if needed</span>
        <span class="k">return</span> <span class="n">g</span>


<span class="c1"># class for online processing</span>
<span class="k">class</span> <span class="nc">Stream</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Stream handles live (i.e. online, real-time) audio input via PyAudio.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    sample_rate : int</span>
<span class="sd">        Sample rate of the signal.</span>
<span class="sd">    num_channels : int, optional</span>
<span class="sd">        Number of channels.</span>
<span class="sd">    dtype : numpy dtype, optional</span>
<span class="sd">        Data type for the signal.</span>
<span class="sd">    frame_size : int, optional</span>
<span class="sd">        Size of one frame [samples].</span>
<span class="sd">    hop_size : int, optional</span>
<span class="sd">        Progress `hop_size` samples between adjacent frames.</span>
<span class="sd">    fps : float, optional</span>
<span class="sd">        Use given frames per second; if set, this computes and overwrites the</span>
<span class="sd">        given `hop_size` value (the resulting `hop_size` must be an integer).</span>
<span class="sd">    queue_size : int</span>
<span class="sd">        Size of the FIFO (first in first out) queue. If the queue is full and</span>
<span class="sd">        new audio samples arrive, the oldest item in the queue will be dropped.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Stream is implemented as an iterable which blocks until enough new data is</span>
<span class="sd">    available.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="o">=</span><span class="n">SAMPLE_RATE</span><span class="p">,</span> <span class="n">num_channels</span><span class="o">=</span><span class="n">NUM_CHANNELS</span><span class="p">,</span>
                 <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">frame_size</span><span class="o">=</span><span class="n">FRAME_SIZE</span><span class="p">,</span> <span class="n">hop_size</span><span class="o">=</span><span class="n">HOP_SIZE</span><span class="p">,</span>
                 <span class="n">fps</span><span class="o">=</span><span class="n">FPS</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># import PyAudio here and not at the module level</span>
        <span class="kn">import</span> <span class="nn">pyaudio</span>
        <span class="c1"># set attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">=</span> <span class="n">sample_rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">num_channels</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">if</span> <span class="n">frame_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame_size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fps</span><span class="p">:</span>
            <span class="c1"># use fps instead of hop_size</span>
            <span class="n">hop_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">fps</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">hop_size</span><span class="p">)</span> <span class="o">!=</span> <span class="n">hop_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;only integer `hop_size` supported, not </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">hop_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">hop_size</span><span class="p">)</span>
        <span class="c1"># init PyAudio</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span> <span class="o">=</span> <span class="n">pyaudio</span><span class="o">.</span><span class="n">PyAudio</span><span class="p">()</span>
        <span class="c1"># init a stream to read audio samples from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                                   <span class="n">channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span><span class="p">,</span>
                                   <span class="nb">format</span><span class="o">=</span><span class="n">pyaudio</span><span class="o">.</span><span class="n">paFloat32</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                   <span class="n">frames_per_buffer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span>
                                   <span class="n">start</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># create a buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">BufferProcessor</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">)</span>
        <span class="c1"># frame index counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># PyAudio flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paComplete</span> <span class="o">=</span> <span class="n">pyaudio</span><span class="o">.</span><span class="n">paComplete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paContinue</span> <span class="o">=</span> <span class="n">pyaudio</span><span class="o">.</span><span class="n">paContinue</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># get the desired number of samples (block until all are present)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span> <span class="n">exception_on_overflow</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># convert it to a numpy array</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;float32&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># buffer the data (i.e. append hop_size samples and rotate)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="c1"># wrap the last frame_size samples as a Signal</span>
        <span class="c1"># TODO: check float / int hop size; theoretically a float hop size</span>
        <span class="c1">#       can be accomplished by making the buffer N samples bigger and</span>
        <span class="c1">#       take the correct portion of the buffer</span>
        <span class="n">start</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">hop_size</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">Signal</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span><span class="p">:],</span> <span class="n">sample_rate</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>
                        <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">num_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_channels</span><span class="p">,</span>
                        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">)</span>
        <span class="c1"># increment the frame index</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">signal</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="fm">__next__</span>

    <span class="k">def</span> <span class="nf">is_running</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">is_active</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stream</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="c1"># TODO: is this the correct place to terminate PyAudio?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pa</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Shape of the Stream (None, frame_size[, num_channels]).&quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_size</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">num_channels</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">shape</span> <span class="o">+=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">num_channels</span><span class="p">,)</span>
        <span class="k">return</span> <span class="n">shape</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../../index.html">Audio Tagger 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="../../index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2019, Alexander Moser.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 2.0.1.
    </div>
  </body>
</html>